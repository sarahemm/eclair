# ECLair Microcode

# files - output files with which bit positions go in each one
file  microcode.bin  0   64

# fields - names for bit positions
# edge-sensitive signals
field write_pte     0     1
field load_mdr      1     1
# bit 2 is currently available
field load_mar      3     1
field load_ir       4     1
field inc_pc        5     1
field load_pc       6     1
field load_reg      7     3
field load_x        10    1
field load_y        11    1
field load_z        12    1
field load_ptb      13    1
field load_flags    14    1
field load_status   15    1
field clr_intflg    16    1
field mem_write     17    1
# level-sensitive signals
field xy_imm_lsb    24    1
field next_addr     25    8
field src_mar       33    1
field src_mdr       34    1
field alu_mode      35    1
field alu_op        36    4
field src_xy        40    3
field mem_read      43    1
field data_bus_src  44    1
field op_16bit      45    1
field branch_cond   46    3
field mdr_byte      49    1

# enums - names for values that go into bit positions
enum  src_mar     z       0
enum  src_mar     pc      1
enum  src_mdr     z       0
enum  src_mdr     data    1
enum  load_reg    a       1
enum  load_reg    b       2
enum  load_reg    c       3
enum  load_reg    d       4
enum  load_reg    sp      5
enum  load_reg    via_ir  7
enum  alu_mode    arith   0
enum  alu_mode    logic   1
enum  alu_op      x       0
enum  alu_op      add     6
enum  xy_imm_lsb  0       0
enum  xy_imm_lsb  1       1
enum  src_xy      imm     0
enum  src_xy      a       1
enum  src_xy      b       2
enum  src_xy      c       3
enum  src_xy      d       4
enum  src_xy      sp      5
enum  src_xy      mar     6
enum  src_xy      mdr     7
enum  branch_cond always  0
enum  branch_cond z       1
enum  branch_cond co      2
enum  mdr_byte    low     0
enum  mdr_byte    high    1

# locations - start addresses of instructions
location    init        0
location    fetch       2
location    fetch2      3
location    ldi8.al     5     # load immediate 8 bits into low byte of a
location    ldi8.bl     69    # load immediate 8 bits into low byte of b
location    ldi8.cl     133   # load immediate 8 bits into low byte of c
location    ldi8.dl     197   # load immediate 8 bits into low byte of d
location    ldi8.?l     200   # load immediate 8 bits into register from IR
location    ldi16.a     6     # load immediate 16 bits into a
location    ldi16.b     70    # load immediate 16 bits into b
location    ldi16.c     134   # load immediate 16 bits into c
location    ldi16.d     198   # load immediate 16 bits into d
location    ldi16.sp    39    # load immediate 16 bits into sp
location    ldi16.?     203   # load immediate 16 bits into register from IR
location    ldi8.ptb    7     # load immediate 8 bits into PTB register
location    add16.ab    11    # add a and b registers, result goes into a
location    jmp         14    # unconditional immediate jump
location    wrpte       18    # write page table entry using data in a and address in d
location    ldi8.flags  21    # load immediate 8 bits into system flags
location    add8.ab     24    # add lower 8 bits of a and b registers, result goes into a
location    jmpz        27    # jump if Z
location    push8.imm   31    # push immediate 8 bits to address pointed to by SP++
location    push8.?     33    # common latter half of push8.*
location    push16.imm  44    # push immediate 16 bits to address pointed to by SP++
location    push16.?    47    # common latter half of push16.*
location    hlt         254

# instructions - each one is one word of microcode, glues everything above together
instruction init        src_xy(imm)   alu_mode(arith)   alu_op(x) load_x      load_y  load_z
instruction init        load_pc       next_addr(fetch2)

instruction fetch       inc_pc
instruction fetch2      src_mar(pc)   load_mar          mem_read  load_ir     next_addr(ir)

instruction ldi8.al     next_addr(ldi8.?l)
instruction ldi8.bl     next_addr(ldi8.?l)
instruction ldi8.cl     next_addr(ldi8.?l)
instruction ldi8.dl     next_addr(ldi8.?l)

instruction ldi16.a     next_addr(ldi16.?)
instruction ldi16.b     next_addr(ldi16.?)
instruction ldi16.c     next_addr(ldi16.?)
instruction ldi16.d     next_addr(ldi16.?)

instruction ldi8.ptb    inc_pc        src_mar(pc)   load_mar        mem_read        src_mdr(data) mdr_byte(low) load_mdr        src_xy(mdr)   load_x    load_z      load_ptb
instruction ldi8.ptb    next_addr(fetch)

instruction ldi8.flags  inc_pc        src_mar(pc)   load_mar        mem_read        src_mdr(data) mdr_byte(low) load_mdr        src_xy(mdr)   load_x    load_z      load_status
instruction ldi8.flags  load_flags    next_addr(fetch)

instruction ldi16.sp    inc_pc        src_mar(pc)   src_mdr(data)   src_xy(mdr)     mem_read    load_mar        mdr_byte(low)   load_mdr
instruction ldi16.sp                  src_mar(pc)   src_mdr(data)   src_xy(mdr)     mem_read    inc_pc          op_16bit
instruction ldi16.sp                  src_mar(pc)   src_mdr(data)   src_xy(mdr)     mem_read    load_mar        mdr_byte(high)  load_mdr      load_y    load_x      load_z  load_reg(sp)  op_16bit  load_status
instruction ldi16.sp    next_addr(fetch)

instruction ldi8.?l     inc_pc        src_mar(pc)     load_mar        mem_read    src_mdr(data)   mdr_byte(low)   load_mdr      src_xy(mdr) load_x    load_z  load_reg(via_ir)    load_status
instruction ldi8.?l     next_addr(fetch)

instruction ldi16.?     inc_pc        src_mar(pc)   src_mdr(data)   src_xy(mdr)     mem_read    load_mar        mdr_byte(low)     load_mdr
instruction ldi16.?                   src_mar(pc)   src_mdr(data)   src_xy(mdr)     mem_read    inc_pc          op_16bit
instruction ldi16.?                   src_mar(pc)   src_mdr(data)   src_xy(mdr)     mem_read    load_mar        mdr_byte(high)    load_mdr      load_y    load_x      load_z  load_reg(via_ir)  op_16bit  load_status
instruction ldi16.?     next_addr(fetch)

instruction add16.ab    src_xy(a)     load_x
instruction add16.ab    src_xy(b)     load_y
instruction add16.ab    alu_mode(arith) alu_op(add)   op_16bit        load_z        load_reg(a)     next_addr(fetch)  load_status

instruction add8.ab     src_xy(a)     load_x
instruction add8.ab     src_xy(b)     load_y
instruction add8.ab     alu_mode(arith) alu_op(add)                   load_z        load_reg(a)     next_addr(fetch)  load_status

instruction jmp         inc_pc        src_mar(pc)     mem_read        load_mar      src_mdr(data)   src_xy(mdr)       mdr_byte(low)   load_mdr
instruction jmp         inc_pc        src_mar(pc)     mem_read        load_mar      src_mdr(data)   src_xy(mdr)       mdr_byte(high)  load_mdr
instruction jmp         src_xy(mdr)   alu_op(x)       load_x          load_z
instruction jmp         branch_cond(always)           load_pc         next_addr(fetch)

instruction jmpz        inc_pc        src_mar(pc)     mem_read        load_mar      src_mdr(data)   src_xy(mdr)       mdr_byte(low)   load_mdr
instruction jmpz        inc_pc        src_mar(pc)     mem_read        load_mar      src_mdr(data)   src_xy(mdr)       mdr_byte(high)  load_mdr
instruction jmpz        src_xy(mdr)   alu_op(x)       load_x          load_z
instruction jmpz        branch_cond(z)                load_pc         next_addr(fetch)

instruction wrpte       alu_op(x)     src_xy(d)       load_x          load_z        src_mar(z)      load_mar
instruction wrpte       alu_op(x)     src_xy(a)       load_x          load_z        load_status
instruction wrpte       write_pte     next_addr(fetch)

# load immediate value from address pointed to by PC into MDR
instruction push8.imm   inc_pc        src_mar(pc)   load_mar        src_mdr(data)   mem_read      mdr_byte(low) load_mdr
instruction push8.imm   next_addr(push8.?)

# load the value of SP into X/Z/MAR
instruction push8.?     alu_op(x)     src_xy(sp)      load_x          load_z        src_mar(z)    load_mar
# write immediate value from MDR into address pointed to by SP (now in Z)
instruction push8.?     src_mar(z)    load_mar        mem_write
# load 1'b1 into Y, add it to X (already contains SP), then put the result back into SP
instruction push8.?     src_xy(imm)   xy_imm_lsb(1)   load_y          
instruction push8.?     alu_op(add)   load_z          load_reg(sp)
# increment PC and jump back to fetching the next instruction
instruction push8.?     next_addr(fetch)

# load immediate value from address pointed to by PC into low byte of MDR
instruction push16.imm  inc_pc        src_mar(pc)   load_mar        src_mdr(data)   mem_read      mdr_byte(low)   load_mdr
# increment pc and load immediate value from address pointed to by PC into high byte of MDR
instruction push16.imm  inc_pc        src_mar(pc)     load_mar        src_mdr(data)   mem_read      mdr_byte(high)  load_mdr
instruction push16.imm  next_addr(push16.?)

# write immediate value from low byte of MDR into address pointed to by SP (via SP->X->Z->MAR)
instruction push16.?    alu_op(x)     src_xy(sp)      load_x          load_z        src_mar(z)      load_mar  mem_write
# increment SP into Z and load that into MAR
instruction push16.?    xy_imm_lsb(1) load_y          alu_op(add)     load_z        src_mar(z)      load_mar 
# write immediate value from high byte of MDR into SP+1
instruction push16.?    mdr_byte(high)  mem_write
# add the 1'b1 already in Y to the SP+1 already in MAR, then put the result (SP+2) back into SP
instruction push16.?    src_xy(mar)   load_x          alu_op(add)     load_z        load_reg(sp)
# increment PC and jump back to fetching the next instruction
instruction push16.?    next_addr(fetch)

instruction hlt         next_addr(hlt)
