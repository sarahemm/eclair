# ECLair Microcode

# files - output binary-text files with which bit positions go in each one
file    microcode.bin  0   64

# images - output true binary image files with which bit positions go in each one
image   microcode.img  0   64

# mapfile - output a map of addresses to instructions for gtkwave to use
mapfile microcode_map.txt

# graphfile - output a digraph of the microcode flow
#graphfile microcode_graph.pdf

# fields - names for bit positions
# edge-sensitive signals
field write_pte       0     1
field load_mdr        1     1
# bit 2 is currently available
field load_mar        3     1
field load_ir         4     1
# bit 5 is currently available
# bit 6 is currently available
field load_reg        7     3
field load_x          10    1
field load_y          11    1
field load_ptb        13    1
field rpt_exec        14    1
field load_status     15    1
field clr_intflg      16    1
field mem_write       17    1
field load_flag_pe    18    1
field load_flag_m     19    1
field load_flag_ie    20    1
# level-sensitive signals
field mdr_byte        24    1
field next_addr       25    8
field src_mar         33    1
field src_mdr         34    1
field alu_mode        35    1
field alu_op          36    4
field src_xy          40    4
field carry_in        44    1
field op_16bit        45    1
field branch_cond     46    3
field xy_imm_lsb      49    2
field rpt_mode        51    1
field reg_byte        52    1
field mem_read        53    1
field rptz_next_addr  54    4
field write_cse       58    1
field inc_pc          59    1
field load_pc         60    1

# enums - names for values that go into bit positions
enum  src_mar     z       0
enum  src_mar     pc      1
enum  src_mdr     z       0
enum  src_mdr     data    1
enum  load_reg    a       1
enum  load_reg    b       2
enum  load_reg    c       3
enum  load_reg    d       4
enum  load_reg    sp      5
enum  load_reg    dp      6
enum  load_reg    via_ir  7
enum  alu_mode    arith   0
enum  alu_mode    logic   1
enum  alu_op      x       0
enum  alu_op      not_x   0
enum  alu_op      x+x     3
enum  alu_op      add     6
enum  alu_op      sub     9
enum  alu_op      x-1     15
enum  xy_imm_lsb  0       0
enum  xy_imm_lsb  1       1
enum  xy_imm_lsb  2       2
enum  xy_imm_lsb  3       3
enum  src_xy      imm      0
enum  src_xy      a        1
enum  src_xy      b        2
enum  src_xy      c        3
enum  src_xy      d        4
enum  src_xy      sp       5
enum  src_xy      mar      6
enum  src_xy      mdr      7
enum  src_xy      intvect  8
enum  src_xy      mar-shr  9
enum  src_xy      mar-sex  10
enum  src_xy      mar-swab 11
enum  src_xy      dp       12
enum  src_xy      from_ir  15
enum  branch_cond always  0
enum  branch_cond z       1
enum  branch_cond co      2
enum  mdr_byte    low     0
enum  mdr_byte    high    1
enum  reg_byte    low     0
enum  reg_byte    high    1
enum  carry_in    0       0
enum  carry_in    1       1
enum  rpt_mode    load    0
enum  rpt_mode    dec     1

# locations - start addresses of instructions
location    init        0
#location    irq1        1
#location    irq2        2
#location    irq3        3
#location    irq4        4
#location    irq5        5
#location    irq6        6
#location    irq7        7
#location    irq8        8
location    init2       223
location    fetch       224
location    fetch2      225
location    ei          23
location    di          38
location    ldi8.al     9     # load immediate 8 bits into low byte of a
location    ldi8.bl     73    # load immediate 8 bits into low byte of b
location    ldi8.cl     137   # load immediate 8 bits into low byte of c
location    ldi8.dl     201   # load immediate 8 bits into low byte of d
location    ldi8.?l     204   # load immediate 8 bits into register from IR
location    ldi8.ah     11    # load immediate 8 bits into high byte of a
location    ldi8.bh     75    # load immediate 8 bits into high byte of b
location    ldi8.ch     139   # load immediate 8 bits into high byte of c
location    ldi8.dh     203   # load immediate 8 bits into high byte of d
location    ldi8.?h     205   # load immediate 8 bits into register from IR
location    ldi16.a     10    # load immediate 16 bits into a
location    ldi16.b     74    # load immediate 16 bits into b
location    ldi16.c     138   # load immediate 16 bits into c
location    ldi16.d     202   # load immediate 16 bits into d
location    ldi16.?     207   # load immediate 16 bits into register from IR
location    ldi16.sp    39    # load immediate 16 bits into sp
location    ldi16.dp    117   # load immediate 16 bits into dp
location    ldi8.ptb    65    # load immediate 8 bits into PTB register
location    ld16.a      58    # load 16-bit value from memory to register a
location    ld16.b      87    # load 16-bit value from memory to register b
location    ld16.c      182   # load 16-bit value from memory to register c
location    ld16.d      192   # load 16-bit value from memory to register d
location    ld16.?      183   # load 16-bit value from memory to register
location    add16.ab    66    # add a and b registers, result goes into a
location    shl16.a     12    # shift register a left
location    shl16.b     76    # shift register b left
location    shl16.c     140   # shift register c left
location    shl16.d     206   # shift register d left
location    shl16.?       100 # shift 16 bits left
location    shl16.?-done  104 # shift 16 bits left (finalization step)
location    shl8.al     13    # shift low byte of register a left
location    shl8.bl     77    # shift low byte of register b left
location    shl8.cl     141   # shift low byte of register c left
location    shl8.dl     210   # shift low byte of register d left
location    shl8.?l     112   # shift low byte of register left
location    shl8.?l-done  116 # shift low byte of register left (finalization step)
location    shl8.ah     32    # shift high byte of register a left
location    shl8.bh     78    # shift high byte of register b left
location    shl8.ch     142   # shift high byte of register c left
location    shl8.dh     222   # shift high byte of register d left
location    shl8.?h     105   # shift high byte of register left
location    shl8.?h-done  110 # shift high byte of register left (finalization step)
location    shr16.a     37    # shift register a right
location    shr16.b     79    # shift register b right
location    shr16.c     143   # shift register c right
location    shr16.d     200   # shift register d right
location    shr16.?     123   # shift 16 bits right
location    shr16.?-done  127 # shift 16 bits right (finalization step)
location    shr8.al     43    # shift low byte of register a right
location    shr8.bl     80    # shift low byte of register b right
location    shr8.cl     144   # shift low byte of register c right
location    shr8.dl     199   # shift low byte of register d right
location    shr8.?l     150   # shift low byte of register left
location    shr8.?l-done 157  # shift low byte of register left (finalization step)
location    shr8.ah     46    # shift high byte of register a right
location    shr8.bh     81    # shift high byte of register b right
location    shr8.ch     145   # shift high byte of register c right
location    shr8.dh     198   # shift high byte of register d right
location    shr8.?h     166   # shift low byte of register left
location    shr8.?h-done 171  # shift low byte of register left (finalization step)
location    jmp         14    # unconditional immediate jump
location    wrpte       18    # write page table entry using data in a and address in d
location    wrcse       90    # write control store entry using data in A-D and address in SP
location    ldi8.flags  21    # load immediate 8 bits into system flags
location    add8.ab     24    # add lower 8 bits of a and b registers, result goes into a
location    sub8.ab     62    # subtract lower 8 bits of a and b registers, result goes into a
location    sex.a       51    # sign extend register a 8->16 bits
location    sex.b       82    # sign extend register b 8->16 bits
location    sex.c       146   # sign extend register c 8->16 bits
location    sex.d       197   # sign extend register d 8->16 bits
location    sex.?       177   # sign extend 8->16 bits
location    swab.a      57    # swap bytes in register a
location    swab.b      86    # swap bytes in register b
location    swab.c      136   # swap bytes in register c
location    swab.d      193   # swap bytes in register d
location    swab.?      181   # swap bytes in register
location    inv.a       54    # invert 16-bit register a
location    inv.b       83    # invert 16-bit register b
location    inv.c       147   # invert 16-bit register c
location    inv.d       196   # invert 16-bit register d
location    inv.?       178   # invert 16-bit register
location    inv.al      55    # invert low byte of register a
location    inv.bl      84    # invert low byte of register b
location    inv.cl      148   # invert low byte of register c
location    inv.dl      195   # invert low byte of register d
location    inv.?l      179   # invert low byte of register
location    inv.ah      56    # invert high byte of register a
location    inv.bh      85    # invert high byte of register b
location    inv.ch      149   # invert high byte of register c
location    inv.dh      194   # invert high byte of register d
location    inv.?h      180   # invert high byte of register
location    jmpz        27    # jump if Z
location    push8.imm   31    # push immediate 8 bits to address pointed to by SP++
location    push8.?     33    # common latter half of push8.*
location    push16.imm  44    # push immediate 16 bits to address pointed to by SP++
location    push16.pc   52    # push PC to address pointed to by SP++
location    push16.?    47    # common latter half of push16.*
location    pop16.pc    92    # pop 16 bits from address pointed to by SP-- into PC
location    cir         175   # clear internal registers (instruction used for testing only)
location    call        211   # push PC to stack then jump immediate
location    halt        254
location    lz          255   # landing zone, required to be all zeroes for control store writer

# aliases - other names for instructions
alias       ret         pop16.pc

# instructions - each one is one word of microcode, glues everything above together
# initialize the cpu when first starting up
instruction init        src_xy(imm)   alu_mode(arith)   alu_op(x) load_x      load_y  next_addr(init2)
instruction init2       load_pc       next_addr(fetch2)

# increment PC to get ready for the next instruction fetch
instruction fetch       inc_pc
# fetch the next instruction and start executing it
instruction fetch2      src_mar(pc)   load_mar          mem_read  load_ir     next_addr(ir)

# enable interrupts
instruction ei          src_xy(imm)   alu_mode(arith)   alu_op(x) xy_imm_lsb(1)   load_x  load_y  load_flag_ie  next_addr(fetch)

# disable interrupts
instruction di          src_xy(imm)   alu_mode(arith)   alu_op(x) xy_imm_lsb(0)   load_x  load_y  load_flag_ie  next_addr(fetch)

# load immediate 8 bits into low byte of supplied register
instruction ldi8.al     next_addr(ldi8.?l)
instruction ldi8.bl     next_addr(ldi8.?l)
instruction ldi8.cl     next_addr(ldi8.?l)
instruction ldi8.dl     next_addr(ldi8.?l)

# load immediate 8 bits into high byte of supplied register
instruction ldi8.ah     next_addr(ldi8.?h)
instruction ldi8.bh     next_addr(ldi8.?h)
instruction ldi8.ch     next_addr(ldi8.?h)
instruction ldi8.dh     next_addr(ldi8.?h)

# load immediate 16 bits into supplied register
instruction ldi16.a     next_addr(ldi16.?)
instruction ldi16.b     next_addr(ldi16.?)
instruction ldi16.c     next_addr(ldi16.?)
instruction ldi16.d     next_addr(ldi16.?)

# load immediate 8 bits into the page table block
instruction ldi8.ptb    inc_pc        src_mar(pc)   load_mar        mem_read        src_mdr(data) mdr_byte(low) load_mdr        src_xy(mdr)   load_x      load_ptb      next_addr(fetch)

# load immediate 8 bits into the FLAGS register
instruction ldi8.flags  inc_pc        src_mar(pc)   load_mar        mem_read        src_mdr(data) mdr_byte(low) load_mdr        src_xy(mdr)   load_x      load_status
instruction ldi8.flags  load_flag_pe  load_flag_m   load_flag_ie    next_addr(fetch)

# load immediate 16 bit into the stack pointer
instruction ldi16.sp    inc_pc        src_mar(pc)   src_mdr(data)   src_xy(mdr)     mem_read    load_mar        mdr_byte(low)   load_mdr
instruction ldi16.sp                  src_mar(pc)   src_mdr(data)   src_xy(mdr)     mem_read    inc_pc          op_16bit
instruction ldi16.sp                  src_mar(pc)   src_mdr(data)   src_xy(mdr)     mem_read    load_mar        mdr_byte(high)  load_mdr      load_y    load_x  load_reg(sp)  op_16bit  load_status
instruction ldi16.sp    next_addr(fetch)

# load immediate 16 bit into the data pointer
# TODO: look at optimizing this and the SP version, step 2 and 3 should be able to be combined?
instruction ldi16.dp    inc_pc        src_mar(pc)   src_mdr(data)   src_xy(mdr)     mem_read    load_mar        mdr_byte(low)   load_mdr
instruction ldi16.dp                  src_mar(pc)   src_mdr(data)   src_xy(mdr)     mem_read    inc_pc          op_16bit
instruction ldi16.dp                  src_mar(pc)   src_mdr(data)   src_xy(mdr)     mem_read    load_mar        mdr_byte(high)  load_mdr      load_x  load_reg(dp)  op_16bit  load_status next_addr(fetch)

# load immediate 8 bits into low byte of register selected by IR[6..7]
instruction ldi8.?l     inc_pc        src_mar(pc)     load_mar        mem_read    src_mdr(data)   mdr_byte(low)   load_mdr      src_xy(mdr)   reg_byte(low) load_x    load_reg(via_ir)    load_status next_addr(fetch)

# load immediate 8 bits into high byte of register selected by IR[6..7]
instruction ldi8.?h     inc_pc        src_mar(pc)     load_mar        mem_read    src_mdr(data)   mdr_byte(high)   load_mdr      src_xy(mdr)   reg_byte(high) load_x    load_reg(via_ir)    load_status next_addr(fetch)

# load immediate 8 bits into register selected by IR[6..7]
instruction ldi16.?     inc_pc        src_mar(pc)   src_mdr(data)   src_xy(mdr)     mem_read    load_mar        mdr_byte(low)     load_mdr
instruction ldi16.?                   inc_pc
instruction ldi16.?                   src_mar(pc)   src_mdr(data)   src_xy(mdr)     mem_read    load_mar        mdr_byte(high)    load_mdr      load_y    load_x  load_reg(via_ir)  op_16bit  load_status next_addr(fetch)

# load 16-bit value from memory to register
# get the supplied memory address into MDR
instruction ld16.a  next_addr(ld16.?)
instruction ld16.b  next_addr(ld16.?)
instruction ld16.c  next_addr(ld16.?)
instruction ld16.d  next_addr(ld16.?)
instruction ld16.?  inc_pc  src_mar(pc) src_mdr(data) src_xy(mdr) mem_read load_mar mdr_byte(low)  load_mdr
instruction ld16.?  inc_pc  src_mar(pc) src_mdr(data) src_xy(mdr) mem_read load_mar mdr_byte(high) load_mdr op_16bit load_x
# add the supplied address and DP and put that into MAR
instruction ld16.?  src_xy(dp)  load_y  alu_op(add)  src_mar(z) load_mar  op_16bit
# load the value from RAM into the register
instruction ld16.?  mem_read  src_mdr(data) mdr_byte(low)  load_mdr xy_imm_lsb(1) src_xy(imm) load_y
instruction ld16.?  src_xy(mar) load_x
instruction ld16.?  alu_op(add) src_mar(z) load_mar
instruction ld16.?  mem_read  src_mdr(data) mdr_byte(high) load_mdr op_16bit src_xy(mdr) load_x load_reg(via_ir) next_addr(fetch)

# add 16 bits from registers A and B, result goes into A
instruction add16.ab    src_xy(a)     load_x
instruction add16.ab    src_xy(b)     load_y
instruction add16.ab    alu_mode(arith) alu_op(add)   op_16bit      load_reg(a)     next_addr(fetch)  load_status

# add 8 bits from low bytes of registers A and B, result goes into A
instruction add8.ab     src_xy(a)     load_x
instruction add8.ab     src_xy(b)     load_y
instruction add8.ab     alu_mode(arith) alu_op(add)                 load_reg(a)     next_addr(fetch)  load_status

# subtract 8 bits from low bytes of registers A and B, result goes into A
instruction sub8.ab     src_xy(a)     load_x
instruction sub8.ab     src_xy(b)     load_y
instruction sub8.ab     alu_mode(arith) alu_op(sub)   carry_in(1)     load_reg(a)     next_addr(fetch)  load_status

# shift supplied 16-bit register left
instruction shl16.a     op_16bit        src_xy(a)         load_x        inc_pc  next_addr(shl16.?)
instruction shl16.b     op_16bit        src_xy(b)         load_x        inc_pc  next_addr(shl16.?)
instruction shl16.c     op_16bit        src_xy(c)         load_x        inc_pc  next_addr(shl16.?)
instruction shl16.d     op_16bit        src_xy(d)         load_x        inc_pc  next_addr(shl16.?)

# shift 16-bit register selected by IR[6..7] left
# load RPT from immediate
instruction shl16.?     mem_read        src_mar(pc)       load_mar      src_mdr(data)     load_mdr
instruction shl16.?     rpt_mode(load)  rpt_exec
# shift left by one bit
instruction shl16.?     op_16bit        alu_op(x+x)       src_mar(z)    load_mar    rpt_mode(dec)     rpt_exec  
instruction shl16.?     op_16bit        src_xy(mar)       load_x        next_addr(-1) rptz_next_addr(shl16.?-done)
# put the result back into the register it came from
instruction shl16.?-done     op_16bit        src_xy(mar)       alu_op(x)     load_x      load_reg(via_ir)  load_status   next_addr(fetch)

# shift low byte of supplied 8-bit register left
instruction shl8.al     mdr_byte(low)   src_xy(a)         load_x        inc_pc  next_addr(shl8.?l)
instruction shl8.bl     mdr_byte(low)   src_xy(b)         load_x        inc_pc  next_addr(shl8.?l)
instruction shl8.cl     mdr_byte(low)   src_xy(c)         load_x        inc_pc  next_addr(shl8.?l)
instruction shl8.dl     mdr_byte(low)   src_xy(d)         load_x        inc_pc  next_addr(shl8.?l)

# shift low byte of register selected by IR[6..7] left
# load RPT from immediate
instruction shl8.?l     mem_read        src_mar(pc)       load_mar      src_mdr(data)     load_mdr
instruction shl8.?l     rpt_mode(load)  rpt_exec
# shift left by one bit
instruction shl8.?l     mdr_byte(low)   alu_op(x+x)       src_mar(z)    load_mar    rpt_mode(dec)     rpt_exec  
instruction shl8.?l     mdr_byte(low)   src_xy(mar)       load_x        next_addr(-1) rptz_next_addr(shl8.?l-done)
# put the result back into the register it came from
instruction shl8.?l-done                src_xy(mar)       alu_op(x)     load_x      load_reg(via_ir)  load_status   next_addr(fetch)

# shift low byte of supplied 8-bit register left
instruction shl8.ah     inc_pc  next_addr(shl8.?h)
instruction shl8.bh     inc_pc  next_addr(shl8.?h)
instruction shl8.ch     inc_pc  next_addr(shl8.?h)
instruction shl8.dh     inc_pc  next_addr(shl8.?h)

# shift high byte of register selected by IR[6..7] left
# TODO: this can almost certainly be optimized
# load RPT from immediate and zero out low byte of MDR so we can later use the high byte alone
instruction shl8.?h     mem_read        src_mar(pc)     load_mar      src_mdr(data)     load_mdr
instruction shl8.?h     xy_imm_lsb(0)   src_xy(imm)     load_x        src_mdr(z) load_mdr  rpt_mode(load)  rpt_exec
# move value from register into MDR (our temp register)
# we can't work in-place as the low byte of the register will get shifted into the high byte
instruction shl8.?h     mdr_byte(high)  src_xy(from_ir) load_x        src_mdr(z) load_mdr
# shift left by one bit
instruction shl8.?h     src_xy(mdr)     load_x          rpt_mode(dec)     rpt_exec  
instruction shl8.?h     alu_op(x+x)     reg_byte(high) load_reg(via_ir)  src_mdr(z) mdr_byte(high) load_mdr load_status  next_addr(-1) rptz_next_addr(shl8.?h-done)
# this is really just here because we can't do long jumps based on rptz
instruction shl8.?h-done    next_addr(fetch)

# shift supplied 16-bit register left
instruction shr16.a     op_16bit        src_xy(a)         load_x        inc_pc  next_addr(shr16.?)
instruction shr16.b     op_16bit        src_xy(b)         load_x        inc_pc  next_addr(shr16.?)
instruction shr16.c     op_16bit        src_xy(c)         load_x        inc_pc  next_addr(shr16.?)
instruction shr16.d     op_16bit        src_xy(d)         load_x        inc_pc  next_addr(shr16.?)

# shift 16-bit register selected by IR[6..7] right
# load RPT from immediate
instruction shr16.?     mem_read        src_mar(pc)       load_mar      src_mdr(data)     load_mdr
# after loading RPT, we start at the 'end' of the loop, since we have to initialize MAR from Z
# before we start shifting
instruction shr16.?     rpt_mode(load)  rpt_exec          next_addr(+2)
# shift right by one bit
instruction shr16.?     op_16bit        src_xy(mar-shr)   load_x        rpt_mode(dec)     rpt_exec
instruction shr16.?     op_16bit        src_mar(z)        load_mar      next_addr(-1)     rptz_next_addr(shr16.?-done)
# put the result back into the register it came from
instruction shr16.?-done     op_16bit        src_xy(mar)       alu_op(x)     load_x      load_reg(via_ir)  load_status   next_addr(fetch)

# shift high byte of supplied 8-bit register right
instruction shr8.ah     inc_pc  next_addr(shr8.?h)
instruction shr8.bh     inc_pc  next_addr(shr8.?h)
instruction shr8.ch     inc_pc  next_addr(shr8.?h)
instruction shr8.dh     inc_pc  next_addr(shr8.?h)

# shift high byte of register selected by IR[6..7] right
# load RPT from immediate
instruction shr8.?h     mem_read        src_mar(pc)       load_mar      src_mdr(data)     load_mdr
instruction shr8.?h     rpt_mode(load)  rpt_exec
# move value from register into MDR (our temp register)
# we can't work in-place as the low byte of the register will get shifted into the high byte
instruction shr8.?h     mdr_byte(high)  src_xy(from_ir)   load_x        src_mdr(z)        load_mdr  next_addr(+2)
# shift left by one bit
instruction shr8.?h     mdr_byte(low)   src_xy(mar-shr)   load_x        rpt_mode(dec)     rpt_exec
instruction shr8.?h     mdr_byte(low)   src_mar(z)        load_mar      next_addr(-1) rptz_next_addr(shr8.?h-done)
# put the result back into the register it came from
instruction shr8.?h-done reg_byte(high) src_xy(mar)       alu_op(x)     load_x      load_reg(via_ir)  load_status   next_addr(fetch)

# shift low byte of supplied 8-bit register right
instruction shr8.al     inc_pc  next_addr(shr8.?l)
instruction shr8.bl     inc_pc  next_addr(shr8.?l)
instruction shr8.cl     inc_pc  next_addr(shr8.?l)
instruction shr8.dl     inc_pc  next_addr(shr8.?l)

# shift low byte of register selected by IR[6..7] right
# TODO: wow, this is kind of a mess and hopefully can be cleaned up once I'm less bored of working on shifts
# load RPT from immediate
instruction shr8.?l     mem_read        src_mar(pc)       load_mar      src_mdr(data)     load_mdr
instruction shr8.?l     rpt_mode(load)  rpt_exec
# move value from low byte of our register into the high byte of MAR
# we can't work in-place as the high byte of the register will get shifted into the low byte
# but we can only shift right using MAR, not MDR, so we have to go reg->MDR->MAR
instruction shr8.?l     mdr_byte(low)   src_xy(from_ir)   load_x        src_mdr(z)        load_mdr
instruction shr8.?l     mdr_byte(high)  xy_imm_lsb(0)     src_xy(imm)   load_x            src_mdr(z)        load_mdr
instruction shr8.?l     src_xy(mdr)     load_x            src_mar(z)    load_mar          next_addr(+2)
# shift left by one bit
instruction shr8.?l     mdr_byte(low)   src_xy(mar-shr)   load_x        rpt_mode(dec)     rpt_exec
instruction shr8.?l     mdr_byte(low)   src_mar(z)        load_mar      next_addr(-1) rptz_next_addr(shr8.?l-done)
# put the result from MAR back into the register it came from
instruction shr8.?l-done src_xy(mar)    load_x            reg_byte(low) load_reg(via_ir)  load_status   next_addr(fetch)

# sign extend
instruction sex.a       src_xy(from_ir)   load_x            src_mar(z)      load_mar          next_addr(sex.?)
instruction sex.b       src_xy(from_ir)   load_x            src_mar(z)      load_mar          next_addr(sex.?)
instruction sex.c       src_xy(from_ir)   load_x            src_mar(z)      load_mar          next_addr(sex.?)
instruction sex.d       src_xy(from_ir)   load_x            src_mar(z)      load_mar          next_addr(sex.?)
instruction sex.?       op_16bit          src_xy(mar-sex)   load_x          load_reg(via_ir)  next_addr(fetch)

# sign extend
instruction swab.a      src_xy(from_ir)   load_x            src_mar(z)      load_mar          next_addr(swab.?)
instruction swab.b      src_xy(from_ir)   load_x            src_mar(z)      load_mar          next_addr(swab.?)
instruction swab.c      src_xy(from_ir)   load_x            src_mar(z)      load_mar          next_addr(swab.?)
instruction swab.d      src_xy(from_ir)   load_x            src_mar(z)      load_mar          next_addr(swab.?)
instruction swab.?      op_16bit          src_xy(mar-swab)  load_x          load_reg(via_ir)  next_addr(fetch)

# invert (not) 16-bit register
instruction inv.a       src_xy(from_ir)   load_x            next_addr(inv.?)
instruction inv.b       src_xy(from_ir)   load_x            next_addr(inv.?)
instruction inv.c       src_xy(from_ir)   load_x            next_addr(inv.?)
instruction inv.d       src_xy(from_ir)   load_x            next_addr(inv.?)
instruction inv.?       op_16bit          alu_mode(logic)   alu_op(not_x)     load_reg(via_ir)    next_addr(fetch)

# invert (not) low byte of register
instruction inv.al      src_xy(from_ir)   load_x            next_addr(inv.?l)
instruction inv.bl      src_xy(from_ir)   load_x            next_addr(inv.?l)
instruction inv.cl      src_xy(from_ir)   load_x            next_addr(inv.?l)
instruction inv.dl      src_xy(from_ir)   load_x            next_addr(inv.?l)
instruction inv.?l      alu_mode(logic)   alu_op(not_x)     load_reg(via_ir)    next_addr(fetch)

# invert (not) high byte of register
instruction inv.ah      src_xy(from_ir)   load_x            next_addr(inv.?h)
instruction inv.bh      src_xy(from_ir)   load_x            next_addr(inv.?h)
instruction inv.ch      src_xy(from_ir)   load_x            next_addr(inv.?h)
instruction inv.dh      src_xy(from_ir)   load_x            next_addr(inv.?h)
instruction inv.?h      reg_byte(high)    alu_mode(logic)   alu_op(not_x)     load_reg(via_ir)    next_addr(fetch)

# immediate jump to the address specified
instruction jmp         inc_pc        src_mar(pc)     mem_read        load_mar      src_mdr(data)   src_xy(mdr)       mdr_byte(low)   load_mdr
instruction jmp         inc_pc        src_mar(pc)     mem_read        load_mar      src_mdr(data)   src_xy(mdr)       mdr_byte(high)  load_mdr
instruction jmp         src_xy(mdr)   alu_op(x)       load_x
instruction jmp         branch_cond(always)           load_pc         next_addr(fetch2)

# immediate jump to the address specified if Z(ero) is true
instruction jmpz        inc_pc        src_mar(pc)     mem_read        load_mar      src_mdr(data)   src_xy(mdr)       mdr_byte(low)   load_mdr
instruction jmpz        inc_pc        src_mar(pc)     mem_read        load_mar      src_mdr(data)   src_xy(mdr)       mdr_byte(high)  load_mdr
instruction jmpz        inc_pc        src_xy(mdr)     alu_op(x)       load_x
instruction jmpz        branch_cond(z)                load_pc         next_addr(fetch2)

# write page table entry, get data from A and write to page table address specified in D
instruction wrpte       alu_op(x)     src_xy(d)       load_x          src_mar(z)      load_mar
instruction wrpte       alu_op(x)     src_xy(a)       load_x          load_status
instruction wrpte       write_pte     next_addr(fetch)

# write control store entry, get data from A-D and write to control store address specific in SP
# due to the need to jump the control store to write to it, this is actually implemented in hardware
# so all we have to do is trigger the write_cse line, which then lets the control store write hardware
# take over execution for a few cycles.
instruction wrcse       write_cse
# this is effectively a noop, just need an extra clock cycle to handle wrcse properly
# TODO: verify this is actually true
instruction wrcse       alu_op(x)     next_addr(fetch)

# load immediate 8 bits into MDR
instruction push8.imm   inc_pc        src_mar(pc)   load_mar        src_mdr(data)   mem_read      mdr_byte(low) load_mdr next_addr(push8.?)

# TODO: better comment
# load the value of SP into X/Z/MAR
instruction push8.?     alu_op(x)     src_xy(sp)      load_x        src_mar(z)    load_mar
# write immediate value from MDR into address pointed to by SP (now in Z)
instruction push8.?     src_mar(z)    load_mar        mem_write
# load 1'b1 into Y
instruction push8.?     src_xy(imm)   xy_imm_lsb(1)   load_y    
# add 1'b1 to X (already contains SP), then put the result back into SP, inc PC and jump back to fetching
instruction push8.?     alu_op(add)   load_reg(sp)    next_addr(fetch)

# push immediate 16 bits onto stack
# load immediate value from address pointed to by PC into low byte of MDR
instruction push16.imm  inc_pc        src_mar(pc)   load_mar        src_mdr(data)   mem_read    mdr_byte(low)   load_mdr
# increment pc and load immediate value from address pointed to by PC into high byte of MDR
instruction push16.imm  inc_pc        src_mar(pc)     load_mar        src_mdr(data)   mem_read  mdr_byte(high)  load_mdr  next_addr(push16.?)

# push program counter onto stack
# pc -> mar -> x -> z -> mdr
instruction push16.pc   src_mar(pc)     load_mar      src_xy(mar)     load_x        alu_op(x)   src_mdr(z)  mdr_byte(low) load_mdr
instruction push16.pc   mdr_byte(high)  src_xy(mdr)   load_mdr        load_x        next_addr(push16.?)

# push 16 bits from register selected by IR[6..7]
# write immediate value from low byte of MDR into address pointed to by SP (via SP->X->Z->MAR)
instruction push16.?    alu_op(x)     src_xy(sp)      load_x          src_mar(z)      load_mar  mem_write
# increment SP into Z and load that into MAR
instruction push16.?    xy_imm_lsb(1) load_y          alu_op(add)     src_mar(z)      load_mar 
# write immediate value from high byte of MDR into SP+1
instruction push16.?    mdr_byte(high)  mem_write
# add the 1'b1 already in Y to the SP+1 already in MAR, put the result (SP+2) back into SP
instruction push16.?    src_xy(mar)   load_x          alu_op(add)     load_reg(sp)    next_addr(fetch)

# pop 16 bits from address pointed to by SP-- into PC
# load SP into MAR
instruction pop16.pc    src_xy(sp)      load_x      alu_op(x-1)   src_mar(z)    load_mar
# load RAM contents into high byte of MDR and load MAR back into SP
instruction pop16.pc    mdr_byte(high)  mem_read    src_mdr(data) load_mdr      src_xy(mar)   load_x  load_reg(sp)
# subtract 1 from SP, put it into the MAR
instruction pop16.pc    src_xy(sp)      alu_op(x-1) src_mar(z)    load_mar
# load RAM contents into the low byte of MDR and push that all the way through to Z
instruction pop16.pc    mdr_byte(low)   mem_read    src_mdr(data) load_mdr      src_xy(mdr)   load_x
# load contents of MDR into PC
instruction pop16.pc    src_xy(mdr)     load_x      load_pc
# load MAR back into SP now that we're done, then fetch next instruction w/o incrementing PC
instruction pop16.pc    src_xy(mar)     load_x      load_reg(sp)  next_addr(fetch2)

# push current pc onto stack then jump to immediate location
instruction call        include(push16.pc,no_next)
instruction call        xy_imm_lsb(3) src_xy(imm) load_y      alu_op(add) load_mdr  
instruction call        include(push16.?,no_next)
instruction call        include(jmp)

# clear internal registers
instruction cir         op_16bit xy_imm_lsb(0) src_xy(imm) load_x load_y src_mar(z) src_mdr(z) load_mar load_mdr
instruction cir         mdr_byte(high) load_mdr rpt_mode(load) rpt_exec next_addr(fetch)

# halt forever
instruction halt        next_addr(halt)

# landing zone - the control store copier 'lands' here at the end and sits forever
# this is required for the control store writer to work, as the data output of that is ORed with
# the control store EPROM to generate the control store RAM data input.
# this must be all zeroes!
instruction lz  next_addr(init)

