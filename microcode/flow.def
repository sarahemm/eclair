# locations - start addresses of instructions
location    jmp         69    # unconditional immediate jump
location    jmpz        27    # jump if Z
location    jmpnz       113   # jump if not Z
location    jmpe        239   # jump if E
location    jmpne       243   # jump if not E
location    call        155   # push PC to stack then jump immediate
location    pop16.pc    92    # pop 16 bits from address pointed to by SP-- into PC
location    cmp16.a?    38    # load two registers into X/Y and set flags
location    cmp16.b?    102   # load two registers into X/Y and set flags
location    cmp16.c?    166   # load two registers into X/Y and set flags
location    cmp16.d?    230   # load two registers into X/Y and set flags
location    cmp16.??    150   # load two registers into X/Y and set flags

# aliases - other names for instructions
alias       ret         pop16.pc
alias       cmp16.aa    cmp16.a?
alias       cmp16.ab    cmp16.a?
alias       cmp16.ac    cmp16.a?
alias       cmp16.ad    cmp16.a?
alias       cmp16.ba    cmp16.b?
alias       cmp16.bb    cmp16.b?
alias       cmp16.bc    cmp16.b?
alias       cmp16.bd    cmp16.b?
alias       cmp16.ca    cmp16.c?
alias       cmp16.cb    cmp16.c?
alias       cmp16.cc    cmp16.c?
alias       cmp16.cd    cmp16.c?
alias       cmp16.da    cmp16.d?
alias       cmp16.db    cmp16.d?
alias       cmp16.dc    cmp16.d?
alias       cmp16.dd    cmp16.d?

# instructions - actual implementation microcode

# immediate jump to the address specified
instruction jmp         inc_pc        src_mar(pc)     mem_read        load_mar      src_mdr(data)   src_xy(mdr)       mdr_byte(high)   load_mdr
instruction jmp         inc_pc        src_mar(pc)     mem_read        load_mar      src_mdr(data)   src_xy(mdr)       mdr_byte(low)  load_mdr
instruction jmp         src_xy(mdr)   alu_op(x)       load_x
instruction jmp         branch_cond(always)           load_pc         next_addr(fetch2)

# immediate jump to the address specified if Z(ero) is true
instruction jmpz        inc_pc        src_mar(pc)     mem_read        load_mar      src_mdr(data)   src_xy(mdr)       mdr_byte(high)   load_mdr
instruction jmpz        inc_pc        src_mar(pc)     mem_read        load_mar      src_mdr(data)   src_xy(mdr)       mdr_byte(low)  load_mdr
instruction jmpz        inc_pc        src_xy(mdr)     alu_op(x)       load_x
instruction jmpz        branch_cond(z)                load_pc         next_addr(fetch2)

# immediate jump to the address specified if Z(ero) is false
instruction jmpnz       inc_pc        src_mar(pc)     mem_read        load_mar      src_mdr(data)   src_xy(mdr)       mdr_byte(high)   load_mdr
instruction jmpnz       inc_pc        src_mar(pc)     mem_read        load_mar      src_mdr(data)   src_xy(mdr)       mdr_byte(low)  load_mdr
instruction jmpnz       inc_pc        src_xy(mdr)     alu_op(x)       load_x
instruction jmpnz       branch_negate branch_cond(z)  load_pc         next_addr(fetch2)

# immediate jump to the address specified if E(qual) is true
instruction jmpe        inc_pc        src_mar(pc)     mem_read        load_mar      src_mdr(data)   src_xy(mdr)       mdr_byte(high)   load_mdr
instruction jmpe        inc_pc        src_mar(pc)     mem_read        load_mar      src_mdr(data)   src_xy(mdr)       mdr_byte(low)  load_mdr
instruction jmpe        inc_pc        src_xy(mdr)     alu_op(x)       load_x
instruction jmpe        branch_cond(e)                load_pc         next_addr(fetch2)

# immediate jgump to the address specified if E(qual) is false
instruction jmpne       inc_pc        src_mar(pc)     mem_read        load_mar      src_mdr(data)   src_xy(mdr)       mdr_byte(high)   load_mdr
instruction jmpne       inc_pc        src_mar(pc)     mem_read        load_mar      src_mdr(data)   src_xy(mdr)       mdr_byte(low)  load_mdr
instruction jmpne       inc_pc        src_xy(mdr)     alu_op(x)       load_x
instruction jmpne       branch_negate branch_cond(e)  load_pc         next_addr(fetch2)

# load two registers into X/Y and set flags
instruction cmp16.a?    inc_pc src_xy(from_ir)  load_x next_addr(cmp16.??)
instruction cmp16.b?    inc_pc src_xy(from_ir)  load_x next_addr(cmp16.??)
instruction cmp16.c?    inc_pc src_xy(from_ir)  load_x next_addr(cmp16.??)
instruction cmp16.d?    inc_pc src_xy(from_ir)  load_x next_addr(cmp16.??)
instruction cmp16.??    src_mar(pc) load_mar  load_rr src_xy(from_rr) load_y
instruction cmp16.??    alu_mode(arith) alu_op(x)   op_16bit      load_status    next_addr(fetch)

# push current pc onto stack then jump to immediate location
instruction call        include(push16.pc,no_next)
instruction call        xy_imm_lsb(3) src_xy(imm) load_y      alu_op(add) load_mdr  
instruction call        include(push16.?,no_next)
instruction call        include(jmp)

# pop 16 bits from address pointed to by SP-- into PC
# load SP into MAR
instruction pop16.pc    src_xy(sp)      load_x      alu_op(x-1)   src_mar(z)    load_mar
# load RAM contents into low byte of MDR and load MAR back into SP
instruction pop16.pc    mdr_byte(low)  mem_read    src_mdr(data) load_mdr      src_xy(mar)   load_x  load_reg(sp)
# subtract 1 from SP, put it into the MAR
instruction pop16.pc    src_xy(sp)      alu_op(x-1) src_mar(z)    load_mar
# load RAM contents into the high byte of MDR and push that all the way through to Z
instruction pop16.pc    mdr_byte(high)   mem_read    src_mdr(data) load_mdr      src_xy(mdr)   load_x
# load contents of MDR into PC
instruction pop16.pc    src_xy(mdr)     load_x      load_pc
# load MAR back into SP now that we're done, then fetch next instruction w/o incrementing PC
instruction pop16.pc    src_xy(mar)     load_x      load_reg(sp)  next_addr(fetch2)
